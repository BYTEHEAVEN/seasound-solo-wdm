// $Id: SoloDriver.cpp,v 1.1 2001/11/25 01:03:13 tekhedd Exp $
//
// Generated by DriverWizard version DriverStudio 2.0.1 (Build 53)
// Requires Compuware's DriverWorks classes
// And Stuff. Nuh huh huh.
// 

#define VDW_MAIN
#include <vdw.h>

#include <windef.h>
#include <portcls.h>		   

#include "SoloDriver.h"
#include "SoloWdmDevice.h"

// Generated by DriverWizard version DriverStudio 2.0.1 (Build 53)

// Set a default 32-bit tag value to be stored with each heap block
// allocated by operator new. Use BoundsChecker to view the memory pool.
// This value can be overridden using the global function SetPoolTag().
POOLTAG DefaultPoolTag('oloS');

// Create the global driver trace object
// TODO:	Use KDebugOnlyTrace if you want trace messages
//			to appear only in debug builds.  Use KTrace if
//			you want trace messages to always appear.	
KDebugOnlyTrace t("SoloDriver");

/////////////////////////////////////////////////////////////////////
// Begin INIT section

DECLARE_DRIVER_CLASS(SoloDriver, NULL)

extern "C" NTSTATUS SoloStartDevice
(
    IN  PDEVICE_OBJECT  DeviceObject,   // Device object. (FDO)
    IN  PIRP            Irp,            // IO request packet.
    IN  PRESOURCELIST   ResourceList    // List of hardware resources.
);

#pragma code_seg()

/////////////////////////////////////////////////////////////////////
//  BHSoloDriver::DriverEntry
//
//	Routine Description:
//		This is the first entry point called by the system when the
//		driver is loaded.
// 
//	Parameters:
//		RegistryPath - String used to find driver parameters in the
//			registry.  To locate BHSoloDriver look for:
//			HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BHSoloDriver
//
//	Return Value:
//		NTSTATUS - Return STATUS_SUCCESS if no errors are encountered.
//			Any other indicates to the system that an error has occured.
//
//	Comments:
//
//#pragma code_seg("INIT")
NTSTATUS SoloDriver::DriverEntry(PUNICODE_STRING RegistryPath)
{
	t << "In DriverEntry\n";

   _thePdo = 0;


	// Open the "Parameters" key under the driver
	KRegistryKey Params(RegistryPath, L"Parameters");
	if ( NT_SUCCESS(Params.LastError()) )
	{
#if DBG
		ULONG bBreakOnEntry = FALSE;
		// Read "BreakOnEntry" value from registry
		Params.QueryValue(L"BreakOnEntry", &_bBreakOnEntry);
		// If requested, break into debugger
		if (bBreakOnEntry) DbgBreakPoint();
#endif
		// Load driver data members from the registry
		LoadRegistryParameters(Params);
	}
	_unit = 0;

	return STATUS_SUCCESS;
}


/////////////////////////////////////////////////////////////////////
//  BHSoloDriver::LoadRegistryParameters
//
//	Routine Description:
//		Load driver data members from the registry.
// 
//	Parameters:
//		Params - Open registry key pointing to "Parameters"
//
//	Return Value:
//		None
//			
//	Comments:
//		Member variables are updated with values read from registry.
//
//		The parameters are found as values under the "Parameters" key,	
//		HKLM\SYSTEM\CurrentControlSet\Services\BHSoloDriver\Parameters\...
//

void SoloDriver::LoadRegistryParameters(KRegistryKey &Params)
{

	_bBreakOnEntry = FALSE;
	Params.QueryValue(L"BreakOnEntry", &_bBreakOnEntry);
	t << "_bBreakOnEntry loaded from registry, resulting value: [" << _bBreakOnEntry << "]\n";

}
// End INIT section
/////////////////////////////////////////////////////////////////////
#pragma code_seg()

/////////////////////////////////////////////////////////////////////
//  BHSoloDriver::AddDevice
//
//	Routine Description:
//		Called when the system detects a device for which this
//		driver is responsible.
//
//	Parameters:
//		Pdo - Physical Device Object. This is a pointer to a system device
//			object that represents the physical device.
//
//	Return Value:
//		NTSTATUS - Success or failure code.
//
//	Comments:
//		This function creates the Functional Device Object, or FDO. The FDO
//		enables this driver to handle requests for the physical device. 
//
#pragma code_seg()
NTSTATUS SoloDriver::AddDevice(PDEVICE_OBJECT Pdo)
{
	t << "AddDevice called\n";

   NTSTATUS       status = STATUS_SUCCESS;

   //
   // Tell the class driver to add the device. If you don't call
   // this, other Pc functions will crash big time.
   //

   // PortClass doesn't pass us the PDO. As a temporary hack, support
   // only one card. :(
   _thePdo = Pdo;
    
   status = PcAddAdapterDevice( DriverObject(),
                                Pdo,
                                PCPFNSTARTDEVICE( SoloStartDevice ),
                                MAX_MINIPORTS,
                                0 );

   if(!NT_SUCCESS(status))
      goto bail;

bail:
   return status;
}

//
// StartDevice -- called by the KS port class object when the
//   IRP_MN_START_DEVICE irp is sent. Let's hope not too much
//   else has happened up to this point.
//
// #pragma code_seg("PAGE")
extern "C" NTSTATUS SoloStartDevice
(
    IN  PDEVICE_OBJECT  DeviceObject,   // Device object. (FDO)
    IN  PIRP            Irp,            // IO request packet.
    IN  PRESOURCELIST   ResourceList    // List of hardware resources.
)
{
    PAGED_CODE();

    SoloDriver * driver = (SoloDriver *)KDriver::DriverInstance();

    return driver->StartWdmDevice( DeviceObject, Irp, ResourceList );
}

NTSTATUS SoloDriver::StartWdmDevice( 
    IN  PDEVICE_OBJECT  DeviceObject,   // Device object. (FDO)
    IN  PIRP            Irp,            // IO request packet.
    IN  PRESOURCELIST   ResourceList    // List of hardware resources.
)
{
   PAGED_CODE();

   NTSTATUS status = STATUS_SUCCESS;

   DbgBreakPoint();

   // Should be able to match the pdo to one of the devices
   // in this object's stack
   {
      PDEVICE_OBJECT dev = DeviceObject;
      while ((dev != NULL) && (dev != _thePdo))
      {
         dev = dev->NextDevice;
      }
   }

   // Insted of using the standard KDevice constructor, use the
   // special one that attaches to an existing systme Device 
   // object. (See KPnpDevice details.)
    SoloWdmDevice * pDevice = 
       new(NonPagedPool) SoloWdmDevice( _thePdo, 
                                        DeviceObject,
                                        _unit );

	if (pDevice == NULL)
	{
		t << "Error creating device SoloWdmAdapter"
			   << (ULONG) _unit << "\n";

      status = STATUS_INSUFFICIENT_RESOURCES;
      goto bail;
	}

	status = pDevice->ConstructorStatus();

	if ( !NT_SUCCESS(status) )
	{
		t << "Error constructing device SoloWdmAdapter"
		  << (ULONG) _unit << " status " << (ULONG) status << "\n";

		delete pDevice;
      goto bail;
	}

   // Success. 
   _unit++;

   pDevice->BelatedOnStartDevice( Irp ); 
	pDevice->ReportNewDevicePowerState(PowerDeviceD0);

bail:
	return status;
}
